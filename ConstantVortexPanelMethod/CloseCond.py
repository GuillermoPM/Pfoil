"""
	This file has the functions to implement the Kutta condition.

"""

import numpy as np
import scipy.integrate as integrate


def KuttaMatrix(Foil):
	"""
	Calculates the Kutta condition for each pannel.
	"""
	paneles = Foil.geom.paneles
	N = Foil.N
	KuttaCond = np.zeros(N+1, float)

	# First source contribution on the last one
	KuttaCond[0] = 0.5/np.pi*integrate.quad(lambda s:
											((paneles[N-1].midx-(paneles[0].xmin-s*np.sin(paneles[0].beta)))*(-np.sin(paneles[N-1].beta))
											 + (paneles[N-1].midy-(paneles[0].ymin+s*np.cos(paneles[0].beta)))*(np.cos(paneles[N-1].beta))) /
											((paneles[N-1].midx-(paneles[0].xmin-s*np.sin(paneles[0].beta)))**2 +
												(paneles[N-1].midy-(paneles[0].ymin+s*np.cos(paneles[0].beta)))**2), 0, paneles[0].len)[0]

	# Last source contribution on the first one
	KuttaCond[N-1] = 0.5/np.pi*integrate.quad(lambda s:
											  ((paneles[0].midx-(paneles[N-1].xmin-s*np.sin(paneles[N-1].beta)))*(-np.sin(paneles[0].beta))
											   + (paneles[0].midy-(paneles[N-1].ymin+s*np.cos(paneles[N-1].beta)))*(np.cos(paneles[0].beta))) /
											  ((paneles[0].midx-(paneles[N-1].xmin-s*np.sin(paneles[N-1].beta)))**2 +
												  (paneles[0].midy-(paneles[N-1].ymin+s*np.cos(paneles[N-1].beta)))**2), 0, paneles[N-1].len)[0]

	# First vortex contribution on the last one
	KuttaCond[N] -= 0.5/np.pi*integrate.quad(lambda s:
											 ((paneles[-1].midx-(paneles[0].xmin-s*np.sin(paneles[0].beta)))*(np.cos(paneles[-1].beta))
											  + (paneles[-1].midy-(paneles[0].ymin+s*np.cos(paneles[0].beta)))*(np.sin(paneles[-1].beta))) /
											 ((paneles[-1].midx-(paneles[0].xmin-s*np.sin(paneles[0].beta)))**2 +
											  (paneles[-1].midy-(paneles[0].ymin+s*np.cos(paneles[0].beta)))**2), 0, paneles[0].len)[0]

	# Last vortex contribution on the first one
	KuttaCond[N] -= 0.5/np.pi*integrate.quad(lambda s:
											 ((paneles[0].midx-(paneles[-1].xmin-s*np.sin(paneles[-1].beta)))*(np.cos(paneles[0].beta))
											  + (paneles[0].midy-(paneles[-1].ymin+s*np.cos(paneles[-1].beta)))*(np.sin(paneles[0].beta))) /
											 ((paneles[0].midx-(paneles[-1].xmin-s*np.sin(paneles[-1].beta)))**2 +
											  (paneles[0].midy-(paneles[-1].ymin+s*np.cos(paneles[-1].beta)))**2), 0, paneles[-1].len)[0]

	KuttaCond[N] -= 1

	for i, panel in enumerate(paneles[1:-1]):
		KuttaCond[i+1] = 0.5/np.pi*(integrate.quad(lambda s:
												   ((paneles[0].midx-(panel.xmin-s*np.sin(panel.beta)))*(-np.sin(paneles[0].beta))
													+ (paneles[0].midy-(panel.ymin+s*np.cos(panel.beta)))*(np.cos(paneles[0].beta))) /
												   ((paneles[0].midx-(panel.xmin-s*np.sin(panel.beta)))**2 +
													   (paneles[0].midy-(panel.ymin+s*np.cos(panel.beta)))**2), 0, panel.len)[0] + integrate.quad(lambda s:
																																				  ((paneles[-1].midx-(panel.xmin-s*np.sin(panel.beta)))*(-np.sin(paneles[-1].beta))
																																				   + (paneles[-1].midy-(panel.ymin+s*np.cos(panel.beta)))*(np.cos(paneles[-1].beta))) /
																																				  ((paneles[-1].midx-(panel.xmin-s*np.sin(panel.beta)))**2 +
																																					  (paneles[-1].midy-(panel.ymin+s*np.cos(panel.beta)))**2), 0, panel.len)[0])

		KuttaCond[N] -= 0.5/np.pi*(integrate.quad(lambda s:
												  ((paneles[0].midx-(panel.xmin-s*np.sin(panel.beta)))*(np.cos(paneles[0].beta))
												   + (paneles[0].midy-(panel.ymin+s*np.cos(panel.beta)))*(np.sin(paneles[0].beta))) /
												  ((paneles[0].midx-(panel.xmin-s*np.sin(panel.beta)))**2 +
												   (paneles[0].midy-(panel.ymin+s*np.cos(panel.beta)))**2), 0, panel.len)[0] + integrate.quad(lambda s:
																																			  ((paneles[-1].midx-(panel.xmin-s*np.sin(panel.beta)))*(np.cos(paneles[-1].beta))
																																			   + (paneles[-1].midy-(panel.ymin+s*np.cos(panel.beta)))*(np.sin(paneles[-1].beta))) /
																																			  ((paneles[-1].midx-(panel.xmin-s*np.sin(panel.beta)))**2 +
																																			   (paneles[-1].midy-(panel.ymin+s*np.cos(panel.beta)))**2), 0, panel.len)[0])
	Foil.cvortm.kuttaCond = KuttaCond


def TangVel(Foil):
	"""
	Gives the tangencial velocity generated by the vortex and source sheet
	
	"""
	paneles = Foil.geom.paneles
	N = Foil.N
	
	Vt_Matrix = np.empty((N, N+1), dtype=float)
	np.fill_diagonal(Vt_Matrix, 0.0)

	for i, panel_i in enumerate(paneles):
		Vt_Matrix[i, N] = -0.5  # Contribuci√≥n gamma/2 de cada panel
		for j, panel_j in enumerate(paneles):
			if j != i:
				Vt_Matrix[i, j] = 0.5/np.pi*integrate.quad(lambda s: ((panel_i.midx-(panel_j.xmin-s*np.sin(panel_j.beta)))*(-np.sin(panel_i.beta))
																	  + (panel_i.midy-(panel_j.ymin+s*np.cos(panel_j.beta)))*(np.cos(panel_i.beta))) /
														   ((panel_i.midx-(panel_j.xmin-s*np.sin(panel_j.beta)))**2 +
															(panel_i.midy-(panel_j.ymin+s*np.cos(panel_j.beta)))**2), 0, panel_j.len)[0]
				Vt_Matrix[i, N] -= 0.5/np.pi*integrate.quad(lambda s: ((panel_i.midx-(panel_j.xmin-s*np.sin(panel_j.beta)))*(np.cos(panel_i.beta))
																	   + (panel_i.midy-(panel_j.ymin+s*np.cos(panel_j.beta)))*(np.sin(panel_i.beta))) /
															((panel_i.midx-(panel_j.xmin-s*np.sin(panel_j.beta)))**2 +
															(panel_i.midy-(panel_j.ymin+s*np.cos(panel_j.beta)))**2), 0, panel_j.len)[0]
	return Vt_Matrix
